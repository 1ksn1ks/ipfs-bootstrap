(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PPing = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PPing=(()=>{var I=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var X=Object.getOwnPropertyNames;var q=Object.prototype.hasOwnProperty;var Y=(o,t)=>{for(var e in t)I(o,e,{get:t[e],enumerable:!0})},K=(o,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of X(t))!q.call(o,n)&&n!==e&&I(o,n,{get:()=>t[n],enumerable:!(r=G(t,n))||r.enumerable});return o};var z=o=>K(I({},"__esModule",{value:!0}),o);var nt={};Y(nt,{PING_PROTOCOL:()=>_,ping:()=>rt});var b=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}};var g=class extends Error{static name="ProtocolError";constructor(t="Protocol error"){super(t),this.name="ProtocolError"}},w=class extends Error{static name="TimeoutError";constructor(t="Timed out"){super(t),this.name="TimeoutError"}};var S=Symbol.for("@libp2p/service-capabilities"),it=Symbol.for("@libp2p/service-dependencies");function x(o,t){if(o===t)return!0;if(o.byteLength!==t.byteLength)return!1;for(let e=0;e<o.byteLength;e++)if(o[e]!==t[e])return!1;return!0}function p(o=0){return new Uint8Array(o)}function d(o=0){return new Uint8Array(o)}function A(o,t){t==null&&(t=o.reduce((n,s)=>n+s.length,0));let e=d(t),r=0;for(let n of o)e.set(n,r),r+=n.length;return e}var D=Symbol.for("@achingbrain/uint8arraylist");function N(o,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let r of o){let n=e+r.byteLength;if(t<n)return{buf:r,index:t-e};e=n}throw new RangeError("index is out of bounds")}function y(o){return!!o?.[D]}var E=class o{bufs;length;[D]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let r of t)if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.push(r);else if(y(r))e+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let r of t.reverse())if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.unshift(r);else if(y(r))e+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=N(this.bufs,t);return e.buf[e.index]}set(t,e){let r=N(this.bufs,t);r.buf[r.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(e+r,t[r]);else if(y(t))for(let r=0;r<t.length;r++)this.set(e+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:r,length:n}=this._subList(t,e);return A(r,n)}subarray(t,e){let{bufs:r,length:n}=this._subList(t,e);return r.length===1?r[0]:A(r,n)}sublist(t,e){let{bufs:r,length:n}=this._subList(t,e),s=new o;return s.length=n,s.bufs=[...r],s}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let r=[],n=0;for(let s=0;s<this.bufs.length;s++){let a=this.bufs[s],u=n,f=u+a.byteLength;if(n=f,t>=f)continue;let m=t>=u&&t<f,l=e>u&&e<=f;if(m&&l){if(t===u&&e===f){r.push(a);break}let i=t-u;r.push(a.subarray(i,i+(e-t)));break}if(m){if(t===0){r.push(a);continue}r.push(a.subarray(t-u));continue}if(l){if(e===f){r.push(a);break}r.push(a.subarray(0,e-u));break}r.push(a)}return{bufs:r,length:e-t}}indexOf(t,e=0){if(!y(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let r=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=r.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let s=256,a=new Int32Array(s);for(let i=0;i<s;i++)a[i]=-1;for(let i=0;i<n;i++)a[r[i]]=i;let u=a,f=this.byteLength-r.byteLength,m=r.byteLength-1,l;for(let i=e;i<=f;i+=l){l=0;for(let h=m;h>=0;h--){let c=this.get(i+h);if(r[h]!==c){l=Math.max(1,h-u[c]);break}}if(l===0)return i}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let r=d(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,e),this.write(r,t)}getInt16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,e)}setInt16(t,e,r){let n=p(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,r),this.write(n,t)}getInt32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,e)}setInt32(t,e,r){let n=p(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,r),this.write(n,t)}getBigInt64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,e)}setBigInt64(t,e,r){let n=p(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,r),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let r=d(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,e),this.write(r,t)}getUint16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,e)}setUint16(t,e,r){let n=p(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,r),this.write(n,t)}getUint32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,e)}setUint32(t,e,r){let n=p(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,r),this.write(n,t)}getBigUint64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,e)}setBigUint64(t,e,r){let n=p(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,r),this.write(n,t)}getFloat32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,e)}setFloat32(t,e,r){let n=p(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,r),this.write(n,t)}getFloat64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,e)}setFloat64(t,e,r){let n=p(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,r),this.write(n,t)}equals(t){if(t==null||!(t instanceof o)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!x(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let r=new o;return r.bufs=t,e==null&&(e=t.reduce((n,s)=>n+s.byteLength,0)),r.length=e,r}};function V(o=32){let t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(o))}function L(o){if(isNaN(o)||o<=0)throw new b("random bytes length must be a Number bigger than 0");return V(o)}var O=class extends Error{constructor(t){super(t),this.name="TimeoutError"}},T=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t}},C=o=>globalThis.DOMException===void 0?new T(o):new DOMException(o),B=o=>{let t=o.reason===void 0?C("This operation was aborted."):o.reason;return t instanceof Error?t:C(t)};function U(o,t){let{milliseconds:e,fallback:r,message:n,customTimers:s={setTimeout,clearTimeout}}=t,a,u,m=new Promise((l,i)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(t.signal){let{signal:c}=t;c.aborted&&i(B(c)),u=()=>{i(B(c))},c.addEventListener("abort",u,{once:!0})}if(e===Number.POSITIVE_INFINITY){o.then(l,i);return}let h=new O;a=s.setTimeout.call(void 0,()=>{if(r){try{l(r())}catch(c){i(c)}return}typeof o.cancel=="function"&&o.cancel(),n===!1?l():n instanceof Error?i(n):(h.message=n??`Promise timed out after ${e} milliseconds`,i(h))},e),(async()=>{try{l(await o)}catch(c){i(c)}})()}).finally(()=>{m.clear(),u&&t.signal&&t.signal.removeEventListener("abort",u)});return m.clear=()=>{s.clearTimeout.call(void 0,a),a=void 0},m}var Q=o=>{let t=o.addEventListener||o.on||o.addListener,e=o.removeEventListener||o.off||o.removeListener;if(!t||!e)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(o),removeListener:e.bind(o)}};function J(o,t,e){let r,n=new Promise((s,a)=>{if(e={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...e},!(e.count>=0&&(e.count===Number.POSITIVE_INFINITY||Number.isInteger(e.count))))throw new TypeError("The `count` option should be at least 0 or more");e.signal?.throwIfAborted();let u=[t].flat(),f=[],{addListener:m,removeListener:l}=Q(o),i=async(...c)=>{let P=e.multiArgs?c:c[0];if(e.filter)try{if(!await e.filter(P))return}catch($){r(),a($);return}f.push(P),e.count===f.length&&(r(),s(f))},h=(...c)=>{r(),a(e.rejectionMultiArgs?c:c[0])};r=()=>{for(let c of u)l(c,i);for(let c of e.rejectionEvents)u.includes(c)||l(c,h)};for(let c of u)m(c,i);for(let c of e.rejectionEvents)u.includes(c)||m(c,h);e.signal&&e.signal.addEventListener("abort",()=>{h(e.signal.reason)},{once:!0}),e.resolveImmediately&&s(f)});if(n.cancel=r,typeof e.timeout=="number"){let s=U(n,{milliseconds:e.timeout});return s.cancel=()=>{r(),s.clear()},s}return n}function M(o,t,e){typeof e=="function"&&(e={filter:e}),e={...e,count:1,resolveImmediately:!1};let r=J(o,t,e),n=r.then(s=>s[0]);return n.cancel=r.cancel,n}function W(o){return o.reason}async function R(o,t,e){if(t==null)return o;let r=e?.translateError??W;if(t.aborted)return o.catch(()=>{}),Promise.reject(r(t));let n;try{return await Promise.race([o,new Promise((s,a)=>{n=()=>{a(r(t))},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}var _="/ipfs/ping/1.0.0";var j="1.0.0",k="ping",F="ipfs";var v=class{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;constructor(t,e={}){this.components=t,this.started=!1,this.protocol=`/${e.protocolPrefix??F}/${k}/${j}`,this.timeout=e.timeout??1e4,this.maxInboundStreams=e.maxInboundStreams??2,this.maxOutboundStreams=e.maxOutboundStreams??1,this.runOnLimitedConnection=e.runOnLimitedConnection??!0,this.handlePing=this.handlePing.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[S]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handlePing,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}async handlePing(t,e){let r=t.log.newScope("ping");r.trace("ping from %p",e.remotePeer);let n=AbortSignal.timeout(this.timeout);n.addEventListener("abort",()=>{t.abort(new w("Ping timed out"))});let s=Date.now();for await(let a of t){if(t.status!=="open"){r("stream status changed to %s",t.status);break}t.send(a)||(r("waiting for stream to drain"),await M(t,"drain",{rejectionEvents:["close"],signal:n}),r("stream drained"))}r("ping from %p complete in %dms",e.remotePeer,Date.now()-s),await t.close({signal:n})}async ping(t,e={}){let r=L(32),n=await this.components.connectionManager.openStream(t,this.protocol,{runOnLimitedConnection:this.runOnLimitedConnection,...e}),s=n.log.newScope("ping");try{let a=Date.now(),u=Promise.withResolvers(),f=new E,m=l=>{if(f.append(l.data),f.byteLength===32){n.removeEventListener("message",m);let i=Date.now()-a;Promise.all([n.closeRead(e)]).then(()=>{if(x(r,f.subarray()))u.resolve(i);else throw new g(`Received wrong ping ack after ${i}ms`)}).catch(h=>{n.abort(h),u.reject(h)})}};return n.addEventListener("message",m),n.send(r),await n.close(e),await R(u.promise,e.signal)}catch(a){throw s.error("error while pinging %o - %e",t,a),n?.abort(a),a}finally{n?.close()}}};function rt(o={}){return t=>new v(t,o)}return z(nt);})();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
return Libp2PPing}));
//# sourceMappingURL=index.min.js.map
